# Telegram alert + proposal preview setup
base_path = Path("/mnt/data/from pathlib import Path
from zipfile import ZipFile

# Telegram alert + proposal preview setup
base_path = Path("/mnt/data/SafeVault-Telegram-Preview")
scripts_path = base_path / "scripts"
workflows_path = base_path / ".github" / "workflows"
scripts_path.mkdir(parents=True, exist_ok=True)
workflows_path.mkdir(parents=True, exist_ok=True)

# Telegram + preview GitHub Action
workflow = """
name: üîî Telegram Alert + Proposal Preview

on:
  issue_comment:
    types: [created]

jobs:
  telegram-propose-preview:
    if: startsWith(github.event.comment.body, '/propose-eth') || startsWith(github.event.comment.body, '/propose-token')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install deps
        run: npm install node-fetch@2 ethers@5

      - name: Run Telegram + Preview Logic
        env:
          SAFE_ADDRESS: ${{ secrets.SAFE_ADDRESS }}
          SAFE_RPC_URL: ${{ secrets.SAFE_RPC_URL }}
          REOWN_API_KEY: ${{ secrets.REOWN_API_KEY }}
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: node scripts/sendProposalWithPreview.js
"""

(workflows_path / "telegram-preview.yml").write_text(workflow.strip())

# Telegram + proposal preview logic
script = """
const fetch = require("node-fetch");
const { ethers } = require("ethers");

const comment = process.env.COMMENT_BODY;
const safeAddress = process.env.SAFE_ADDRESS;
const rpcUrl = process.env.SAFE_RPC_URL;
const apiKey = process.env.REOWN_API_KEY;
const telegramToken = process.env.TELEGRAM_TOKEN;
const telegramChatId = process.env.TELEGRAM_CHAT_ID;

const ERC20_ABI = [
  "function transfer(address to, uint256 amount)",
  "function decimals() view returns (uint8)"
];

const parseCommand = (body) => {
  const parts = body.trim().split(/\\s+/);
  if (parts[0] === "/propose-eth" && parts.length === 3) {
    return { type: "eth", to: parts[1], amount: parts[2] };
  } else if (parts[0] === "/propose-token" && parts.length === 4) {
    return { type: "token", token: parts[1], to: parts[2], amount: parts[3] };
  } else {
    throw new Error("Invalid command format.");
  }
};

(async () => {
  try {
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl);
    const { type, token, to, amount } = parseCommand(comment);

    let tx = {};
    let description = "";

    if (type === "eth") {
      const ethValue = ethers.utils.parseEther(amount);
      tx = { to, value: ethValue.toString(), data: "0x", operation: 0 };
      description = `Send ${amount} ETH to ${to}`;
    } else {
      const contract = new ethers.Contract(token, ERC20_ABI, provider);
      let decimals = 18;
      try {
        decimals = await contract.decimals();
      } catch {}
      const iface = new ethers.utils.Interface(ERC20_ABI);
      const data = iface.encodeFunctionData("transfer", [
        to,
        ethers.utils.parseUnits(amount, decimals),
      ]);
      tx = { to: token, value: "0", data, operation: 0 };
      description = `Send ${amount} tokens from ${token} to ${to}`;
    }

    // Preview transaction (simulate, no broadcast)
    const preview = await provider.call({
      to: tx.to,
      data: tx.data,
      value: tx.value,
    });

    // Propose transaction
    const res = await fetch("https://api.reown.com/safe/propose", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        safeAddress,
        rpcUrl,
        tx,
        description
      })
    });

    const explorerUrl = `https://app.safe.global/transactions/queue?safe=${safeAddress}`;
    const msg = res.ok
      ? `‚úÖ Proposal Created: ${description}\\n[View in Safe](${explorerUrl})`
      : `‚ùå Proposal Failed\\n${await res.text()}`;

    // Telegram alert
    await fetch(`https://api.telegram.org/bot${telegramToken}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: telegramChatId,
        text: `üîê Safe Proposal Triggered\\n${description}`,
        parse_mode: "Markdown"
      })
    });

    console.log("üì® Telegram notification sent.");
  } catch (err) {
    console.error("‚ö†Ô∏è Error:", err.message);
  }
})();
"""

(scripts_path / "sendProposalWithPreview.js").write_text(script.strip())

# README
readme = """
# üõé Telegram + Preview Proposal Flow

## ‚úÖ Supported Commands:
- /propose-eth 0xRecipient 1.0
- /propose-token 0xToken 0xRecipient 250

## üîß Features:
- Simulates transaction before proposing
- Sends Telegram alert when proposal created
- Posts to Safe via Reown

## üîê Secrets Required:
- SAFE_ADDRESS
- SAFE_RPC_URL
- REOWN_API_KEY
- TELEGRAM_TOKEN
- TELEGRAM_CHAT_ID
"""

(base_path / "README.md").write_text(readme.strip())

# Zip the drop
zip_file = Path("/mnt/data/SafeVault-Telegram-Preview.zip")
with ZipFile(zip_file, "w") as zipf:
    for file in base_path.rglob("*"):
        if file.is_file():
            zipf.write(file, file.relative_to(base_path))

zip_file.name
scripts_path = base_path / "scripts"
workflows_path = base_path / ".github" / "workflows"
scripts_path.mkdir(parents=True, exist_ok=True)
workflows_path.mkdir(parents=True, exist_ok=True)

# Telegram + preview GitHub Action
workflow = """
name: üîî Telegram Alert + Proposal Preview

on:
  issue_comment:
    types: [created]

jobs:
  telegram-propose-preview:
    if: startsWith(github.event.comment.body, '/propose-eth') || startsWith(github.event.comment.body, '/propose-token')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install deps
        run: npm install node-fetch@2 ethers@5

      - name: Run Telegram + Preview Logic
        env:
          SAFE_ADDRESS: ${{ secrets.SAFE_ADDRESS }}
          SAFE_RPC_URL: ${{ secrets.SAFE_RPC_URL }}
          REOWN_API_KEY: ${{ secrets.REOWN_API_KEY }}
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: node scripts/sendProposalWithPreview.js
"""

(workflows_path / "telegram-preview.yml").write_text(workflow.strip())

# Telegram + proposal preview logic
script = """
const fetch = require("node-fetch");
const { ethers } = require("ethers");

const comment = process.env.COMMENT_BODY;
const safeAddress = process.env.SAFE_ADDRESS;
const rpcUrl = process.env.SAFE_RPC_URL;
const apiKey = process.env.REOWN_API_KEY;
const telegramToken = process.env.TELEGRAM_TOKEN;
const telegramChatId = process.env.TELEGRAM_CHAT_ID;

const ERC20_ABI = [
  "function transfer(address to, uint256 amount)",
  "function decimals() view returns (uint8)"
];

const parseCommand = (body) => {
  const parts = body.trim().split(/\\s+/);
  if (parts[0] === "/propose-eth" && parts.length === 3) {
    return { type: "eth", to: parts[1], amount: parts[2] };
  } else if (parts[0] === "/propose-token" && parts.length === 4) {
    return { type: "token", token: parts[1], to: parts[2], amount: parts[3] };
  } else {
    throw new Error("Invalid command format.");
  }
};

(async () => {
  try {
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl);
    const { type, token, to, amount } = parseCommand(comment);

    let tx = {};
    let description = "";

    if (type === "eth") {
      const ethValue = ethers.utils.parseEther(amount);
      tx = { to, value: ethValue.toString(), data: "0x", operation: 0 };
      description = `Send ${amount} ETH to ${to}`;
    } else {
      const contract = new ethers.Contract(token, ERC20_ABI, provider);
      let decimals = 18;
      try {
        decimals = await contract.decimals();
      } catch {}
      const iface = new ethers.utils.Interface(ERC20_ABI);
      const data = iface.encodeFunctionData("transfer", [
        to,
        ethers.utils.parseUnits(amount, decimals),
      ]);
      tx = { to: token, value: "0", data, operation: 0 };
      description = `Send ${amount} tokens from ${token} to ${to}`;
    }

    // Preview transaction (simulate, no broadcast)
    const preview = await provider.call({
      to: tx.to,
      data: tx.data,
      value: tx.value,
    });

    // Propose transaction
    const res = await fetch("https://api.reown.com/safe/propose", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        safeAddress,
        rpcUrl,
        tx,
        description
      })
    });

    const explorerUrl = `https://app.safe.global/transactions/queue?safe=${safeAddress}`;
    const msg = res.ok
      ? `‚úÖ Proposal Created: ${description}\\n[View in Safe](${explorerUrl})`
      : `‚ùå Proposal Failed\\n${await res.text()}`;

    // Telegram alert
    await fetch(`https://api.telegram.org/bot${telegramToken}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: telegramChatId,
        text: `üîê Safe Proposal Triggered\\n${description}`,
        parse_mode: "Markdown"
      })
    });

    console.log("üì® Telegram notification sent.");
  } catch (err) {
    console.error("‚ö†Ô∏è Error:", err.message);
  }
})();
"""

(scripts_path / "sendProposalWithPreview.js").write_text(script.strip())

# README
readme = """
# üõé Telegram + Preview Proposal Flow

## ‚úÖ Supported Commands:
- /propose-eth 0xRecipient 1.0
- /propose-token 0xToken 0xRecipient 250

## üîß Features:
- Simulates transaction before proposing
- Sends Telegram alert when proposal created
- Posts to Safe via Reown

## üîê Secrets Required:
- SAFE_ADDRESS
- SAFE_RPC_URL
- REOWN_API_KEY
- TELEGRAM_TOKEN
- TELEGRAM_CHAT_ID
"""

(base_path / "README.md").write_text(readme.strip())

# Zip the drop
zip_file = Path("/mnt/data/SafeVault-Telegram-Preview.zip")
with ZipFile(zip_file, "w") as zipf:
    for file in base_path.rglob("*"):
        if file.is_file():
            zipf.write(file, file.relative_to(base_path))

zip_file.name
